Help on package n0struct:

NAME
    n0struct

DESCRIPTION
    # 0.01 = 2020-07-25 = Initial version
    # 0.02 = 2020-07-26 = Enhancements
    # 0.03 = 2020-08-02 = Huge enhancements
    # 0.04 = 2020-08-05 = Prepared for upload to pypi.org
    # 0.05 = 2020-08-11 = Huge enhancements: unification of .*compare() .toJson(), .toXml(), n0dict(JSON/XML string)
    # 0.06
    # 0.07 = 2020-09-02 = transform added
    # 0.08 = 2020-09-05 = refactoring
    # 0.09 = lost
    # 0.10 = rewritten date related functions

PACKAGE CONTENTS
    test (package)

CLASSES
    builtins.list(builtins.object)
        n0list
    collections.OrderedDict(builtins.dict)
        n0dict
    
    class n0dict(collections.OrderedDict)
     |  n0dict(*args, **kw)
     |  
     |  Dictionary that remembers insertion order
     |  
     |  Method resolution order:
     |      n0dict
     |      collections.OrderedDict
     |      builtins.dict
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  AddElem(self, where: 'str', what: 'str' = None, value: 'str' = None)
     |      Public function:
     |      Convert path where:str into list, remove all empty separators ("//" or leading/trailing "/"),
     |      find element with path where:str, from the root (super(n0dict, self)),
     |      unpack tuple with "*" into list of arguments,
     |      create sub-nodes' name[s] if they[/it] do[es]n't exist ONLY.
     |      
     |      If optional argument 'what' is provided, add sub-nodes. If sub-nodes exist, CONVERT THEM INTO LIST AND ADD NEW ITEM.
     |      If optional argument 'value' is provided, put into destination path where+what.
     |  
     |  __getitem__(self, where: 'str')
     |      Private function:
     |      return self[where1/where2/.../whereN]
     |          AKA
     |      return self[where1][where2]...[whereN]
     |      
     |      If any of [where1][where2]...[whereN] are not found, exception IndexError will be raised
     |  
     |  __init__(self, *args, **kw)
     |      args == tuple, kw == mapping(dictionary)
     |      
     |      * == convert from tuple into list of arguments
     |      ** == convert from mapping into list of named arguments
     |      
     |      :param args:
     |      :param kw:
     |  
     |  __setitem__(self, where: 'str', value: 'str')
     |      Private function:
     |      self[=?where1/where2/.../whereN] = value
     |          AKA
     |      self[where1][where2]...[whereN] = value
     |      
     |      if 'where' starts with '=', then
     |          the value will be rewritten
     |          If any of [where1][where2]...[whereN] are not found, exception IndexError will be raised
     |      else
     |          the path will be created. if last element exists, then the element will be reconfigured into array
     |          if any whereN starts with '+', then the element will be reconfigured into array
     |  
     |  compare(self, other: 'n0dict', self_name: 'str' = 'self', other_name: 'str' = 'other', prefix: 'str' = '', continuity_check='continuity_check', one_of_list_compare=<function n0list.compare at 0x00000249D31F2310>, composite_key: 'tuple' = (), compare_only: 'tuple' = (), exclude: 'tuple' = (), transform: 'tuple' = ()) -> 'n0dict'
     |      # ******************************************************************************
     |      # * n0dict. compare(..)
     |      # ******************************************************************************
     |  
     |  direct_compare(self, other: 'n0dict', self_name: 'str' = 'self', other_name: 'str' = 'other', prefix: 'str' = '', continuity_check='continuity_check', one_of_list_compare=<function n0list.direct_compare at 0x00000249D31F2280>, composite_key: 'tuple' = (), compare_only: 'tuple' = (), exclude: 'tuple' = (), transform: 'tuple' = ()) -> 'n0dict'
     |      # ******************************************************************************
     |      # * n0dict. direct_compare(..)
     |      # ******************************************************************************
     |  
     |  isEqual(self, xpath, value)
     |      Public function: return empty lists in dict, if self[xpath] == value
     |  
     |  isExist(self, xpath)
     |      Public function: return empty lists in dict, if self[xpath] exists
     |  
     |  isTheSame(self, xpath, other_n0dict, other_xpath=None, transformation=<function n0dict.<lambda> at 0x00000249D31F2DC0>)
     |      Public function: return empty lists in dict, if transformation(self[xpath]) == transformation(other_n0dict[other_xpath])
     |  
     |  to_json(self, indent: 'int' = 4) -> 'str'
     |      Public function: export self into json result string
     |  
     |  to_xml(self, indent: 'int' = 4, encoding: 'str' = 'utf-8') -> 'str'
     |      Public function: export self into xml result string
     |  
     |  to_xpath(self, mode: 'int' = None) -> 'str'
     |      Public function: collect elements xpath starts from root and print with indents
     |  
     |  update_extend(self, other)
     |      # ******************************************************************************
     |  
     |  xpath(self, mode: 'int' = None) -> 'list'
     |      Public function: collect elements xpath starts from root
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from collections.OrderedDict:
     |  
     |  __delitem__(self, key, /)
     |      Delete self[key].
     |  
     |  __eq__(self, value, /)
     |      Return self==value.
     |  
     |  __ge__(self, value, /)
     |      Return self>=value.
     |  
     |  __gt__(self, value, /)
     |      Return self>value.
     |  
     |  __iter__(self, /)
     |      Implement iter(self).
     |  
     |  __le__(self, value, /)
     |      Return self<=value.
     |  
     |  __lt__(self, value, /)
     |      Return self<value.
     |  
     |  __ne__(self, value, /)
     |      Return self!=value.
     |  
     |  __reduce__(...)
     |      Return state information for pickling
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __reversed__(...)
     |      od.__reversed__() <==> reversed(od)
     |  
     |  __sizeof__(...)
     |      D.__sizeof__() -> size of D in memory, in bytes
     |  
     |  clear(...)
     |      od.clear() -> None.  Remove all items from od.
     |  
     |  copy(...)
     |      od.copy() -> a shallow copy of od
     |  
     |  items(...)
     |      D.items() -> a set-like object providing a view on D's items
     |  
     |  keys(...)
     |      D.keys() -> a set-like object providing a view on D's keys
     |  
     |  move_to_end(self, /, key, last=True)
     |      Move an existing element to the end (or beginning if last is false).
     |      
     |      Raise KeyError if the element does not exist.
     |  
     |  pop(...)
     |      od.pop(k[,d]) -> v, remove specified key and return the corresponding
     |      value.  If key is not found, d is returned if given, otherwise KeyError
     |      is raised.
     |  
     |  popitem(self, /, last=True)
     |      Remove and return a (key, value) pair from the dictionary.
     |      
     |      Pairs are returned in LIFO order if last is true or FIFO order if false.
     |  
     |  setdefault(self, /, key, default=None)
     |      Insert key with a value of default if key is not in the dictionary.
     |      
     |      Return the value for key if key is in the dictionary, else default.
     |  
     |  update(...)
     |      D.update([E, ]**F) -> None.  Update D from dict/iterable E and F.
     |      If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]
     |      If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v
     |      In either case, this is followed by: for k in F:  D[k] = F[k]
     |  
     |  values(...)
     |      D.values() -> an object providing a view on D's values
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from collections.OrderedDict:
     |  
     |  fromkeys(iterable, value=None) from builtins.type
     |      Create a new ordered dictionary with keys from iterable and values set to value.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from collections.OrderedDict:
     |  
     |  __dict__
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from collections.OrderedDict:
     |  
     |  __hash__ = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.dict:
     |  
     |  __contains__(self, key, /)
     |      True if the dictionary has the specified key, else False.
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __len__(self, /)
     |      Return len(self).
     |  
     |  get(self, key, default=None, /)
     |      Return the value for key if key is in the dictionary, else default.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.dict:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
    
    class n0list(builtins.list)
     |  n0list(iterable=(), /)
     |  
     |  Class extended builtins.list(builtins.object) with additional methods:
     |  . direct_compare()  = compare [i] <=> [i]
     |  . compare()         = compare [i] <=> [?] WITHOUT using order
     |  
     |  Method resolution order:
     |      n0list
     |      builtins.list
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  compare(self, other: 'n0list', self_name: 'str' = 'self', other_name: 'str' = 'other', prefix: 'str' = '', continuity_check: 'str' = 'continuity_check', composite_key: 'tuple' = (), compare_only: 'tuple' = (), exclude: 'tuple' = (), transform: 'tuple' = ()) -> 'n0dict'
     |      Recursively compare self[i] with other[?] WITHOUT using order of elements.
     |      If self[i] (other[?] must be the same) is n0list/n0dict,
     |      then goes deeper with n0list. compare(..)/n0dict.direct_compare(..)
     |      
     |      :param other:
     |      :param self_name:
     |      :param other_name:
     |      :param prefix:
     |      :param continuity_check:
     |      :param composite_key:
     |      :param compare_only:
     |      :param exclude:
     |      :param transform:
     |      :return:
     |              n0dict({
     |                  "messages"      : [], # generated for each case of not equality
     |                  "notequal"      : [], # generated if elements with the same xpath and type are not equal
     |                  "selfnotfound"  : [], # generated if elements from other list don't exist in self list
     |                  "othernotfound" : [], # generated if elements from self list don't exist in other list
     |                  "difftypes"     : [], # generated if elements with the same xpath have different types
     |              })
     |              if not returned["messages"]: self and other are totally equal.
     |  
     |  direct_compare(self, other: 'n0list', self_name: 'str' = 'self', other_name: 'str' = 'other', prefix: 'str' = '', continuity_check: 'str' = 'continuity_check', composite_key: 'tuple' = (), compare_only: 'tuple' = (), exclude: 'tuple' = (), transform: 'tuple' = ()) -> 'n0dict'
     |      Recursively compare self[i] with other[i]
     |      strictly according to the order of elements.
     |      If self[i] (other[i] must be the same) is n0list/n0dict, then goes deeper
     |      with n0list.direct_compare/n0dict.direct_compare(..)
     |      
     |      :param self: etalon list for compare.
     |      :param other: list to compare with etalon
     |      :param self_name: <default = "self"> dict/list name, used in result["messages"]
     |      :param other_name: <default = "other"> dict/list name, used in result["messages"]
     |      :param prefix: <default = ""> xpath prefix, used for full xpath generation
     |      :param continuity_check: used for checking that below arguments are defined only with names
     |      :param composite_key:  For compatibility with compare(..)
     |      :param compare_only: For compatibility with compare(..)
     |      :param exclude: ()|None|empty mean nothing to exclude
     |      :param transform: ()|None|empty mean nothing to transform
     |      :return:
     |              n0dict({
     |                  "messages"      : [], # generated for each case of not equality
     |                  "notequal"      : [], # generated if elements with the same xpath and type are not equal
     |                  "selfnotfound"  : [], # generated if elements from other list don't exist in self list
     |                  "othernotfound" : [], # generated if elements from self list don't exist in other list
     |                  "difftypes"     : [], # generated if elements with the same xpath have different types
     |              })
     |              if not returned["messages"]: self and other are totally equal.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.list:
     |  
     |  __add__(self, value, /)
     |      Return self+value.
     |  
     |  __contains__(self, key, /)
     |      Return key in self.
     |  
     |  __delitem__(self, key, /)
     |      Delete self[key].
     |  
     |  __eq__(self, value, /)
     |      Return self==value.
     |  
     |  __ge__(self, value, /)
     |      Return self>=value.
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __getitem__(...)
     |      x.__getitem__(y) <==> x[y]
     |  
     |  __gt__(self, value, /)
     |      Return self>value.
     |  
     |  __iadd__(self, value, /)
     |      Implement self+=value.
     |  
     |  __imul__(self, value, /)
     |      Implement self*=value.
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __iter__(self, /)
     |      Implement iter(self).
     |  
     |  __le__(self, value, /)
     |      Return self<=value.
     |  
     |  __len__(self, /)
     |      Return len(self).
     |  
     |  __lt__(self, value, /)
     |      Return self<value.
     |  
     |  __mul__(self, value, /)
     |      Return self*value.
     |  
     |  __ne__(self, value, /)
     |      Return self!=value.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __reversed__(self, /)
     |      Return a reverse iterator over the list.
     |  
     |  __rmul__(self, value, /)
     |      Return value*self.
     |  
     |  __setitem__(self, key, value, /)
     |      Set self[key] to value.
     |  
     |  __sizeof__(self, /)
     |      Return the size of the list in memory, in bytes.
     |  
     |  append(self, object, /)
     |      Append object to the end of the list.
     |  
     |  clear(self, /)
     |      Remove all items from list.
     |  
     |  copy(self, /)
     |      Return a shallow copy of the list.
     |  
     |  count(self, value, /)
     |      Return number of occurrences of value.
     |  
     |  extend(self, iterable, /)
     |      Extend list by appending elements from the iterable.
     |  
     |  index(self, value, start=0, stop=9223372036854775807, /)
     |      Return first index of value.
     |      
     |      Raises ValueError if the value is not present.
     |  
     |  insert(self, index, object, /)
     |      Insert object before index.
     |  
     |  pop(self, index=-1, /)
     |      Remove and return item at index (default last).
     |      
     |      Raises IndexError if list is empty or index is out of range.
     |  
     |  remove(self, value, /)
     |      Remove first occurrence of value.
     |      
     |      Raises ValueError if the value is not present.
     |  
     |  reverse(self, /)
     |      Reverse *IN PLACE*.
     |  
     |  sort(self, /, *, key=None, reverse=False)
     |      Sort the list in ascending order and return None.
     |      
     |      The sort is in-place (i.e. the list itself is modified) and stable (i.e. the
     |      order of two equal elements is maintained).
     |      
     |      If a key function is given, apply it once to each list item and sort them,
     |      ascending or descending, according to their function values.
     |      
     |      The reverse flag can be set to sort in descending order.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.list:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from builtins.list:
     |  
     |  __hash__ = None

FUNCTIONS
    date_ddmmyyyy(now: 'date' = None, day_delta: 'int' = 0, month_delta: 'int' = 0) -> 'str'
        :param day_delta:
        :param month_delta:
        :return: today + day_delta + month_delta -> str DD-MM-YYYY
    
    date_delta(now: 'date' = None, day_delta: 'int' = 0, month_delta: 'int' = 0) -> 'date'
        :param day_delta:
        :param month_delta:
        :return: today + day_delta + month_delta -> date
    
    date_iso(now: 'date' = None, day_delta: 'int' = 0, month_delta: 'int' = 0) -> 'str'
        :param day_delta:
        :param month_delta:
        :return: today + day_delta + month_delta -> str ISO date format
    
    date_mmyy(now: 'date' = None, day_delta: 'int' = 0, month_delta: 'int' = 0) -> 'str'
        :param day_delta:
        :param month_delta:
        :return: today + day_delta + month_delta -> str MMYY
    
    date_now(now: 'date' = None, day_delta: 'int' = 0, month_delta: 'int' = 0) -> 'str'
        :param day_delta:
        :param month_delta:
        :return: today + day_delta + month_delta -> str 20 characters YYYYMMDDHHMMSSFFFFFF
    
    date_yymm(now: 'date' = None, day_delta: 'int' = 0, month_delta: 'int' = 0) -> 'str'
        :param day_delta:
        :param month_delta:
        :return: today + day_delta + month_delta -> str YYMM
    
    date_yyyymmdd(now: 'date' = None, day_delta: 'int' = 0, month_delta: 'int' = 0) -> 'str'
        :param day_delta:
        :param month_delta:
        :return: today + day_delta + month_delta -> str YYYY-MM-DD
    
    from_ddmmmyy(date_str: 'str') -> 'typing.Union[date, str, None]'
        :param date_str: DD-MMM-YY # 16-JUL-20
        :return: str -> date
    
    from_ddmmyyyy(date_str: 'str') -> 'typing.Union[date, str, None]'
        :param date_str: DD-MM-YYYY # 16-07-2020
        :return: str -> date
    
    from_yyyymmdd(date_str: 'str') -> 'typing.Union[date, str, None]'
        :param date_str: YYYY-MM-DD # 2020-07-16
        :return: str -> date
    
    get__flag_compare_check_different_types()
    
    get__flag_compare_return_difference_of_values()
    
    get_composite_keys(input_list: 'n0list', elemets_for_composite_key: 'tuple') -> 'list'
        serialization all or {elemets_for_composite_key} elements of {input_list[]}
    
    get_key_by_value(dict_: 'dict', value_)
        :param dict_:
        :param value_:
        :return: last key which is associated with value_ in dict_
    
    n0debug(var_name: 'str', level: 'int' = 5)
        Print value of the variable with name {var_name},
        depends of value in global variable {__debug_level}.
        
        :param var_name:
        :param level:
        :return:
    
    n0debug_calc(var_value: 'str', var_name: 'str' = '', level: 'int' = 5)
        Print  calculated value (for example returned by function),
        depends of value in global variable __debug_level.
        
        :param var_value:
        :param var_name:
        :param level:
        :return:
    
    n0debug_object(object_name: 'str', level: 'int' = 5)
    
    n0pretty(item, indent_: 'int' = 0)
        :param item:
        :param indent_:
        :return:
    
    n0print(text: 'str', level: 'int' = 5, internal_call: 'bool' = False, end: 'str' = '\n')
        if {level} <= {__debug_level} then print {text}{end}
        
        :param text:
        :param level:
        :param end:
        :param internal_call:
        :return: None
    
    notemptyitems(item)
        # ******************************************************************************
        # notemptyitems(item):
        #   Check item or recursively subitems of item.
        #   Return count of notempty item/subitems.
        # ******************************************************************************
    
    random_from(from_list: 'list')
        :param from_list:
        :return: from_list[rnd]
    
    rnd(till_not_included: 'int') -> 'int'
        :param till_not_included:
        :return: int [0..till_not_included)
    
    set__debug_level(value: 'int')
    
    set__flag_compare_check_different_types(value)
        if __flag_compare_check_different_types == True, then
        validate type of attributes in .compare()/.direct_compare()
        and return result["difftypes"]
    
    set__flag_compare_return_difference_of_values(value)
        if __flag_compare_return_difference_of_values == True, then
        if values of attributes are different and are int,float,
        return additional element in result["notequal"] with difference
    
    to_date(date_str: 'str') -> 'typing.Union[date, str]'
    
    xpath_match(xpath: 'str', xpath_list)
        # ******************************************************************************
        # xpath_match(xpath: str, xpath_list):
        #   Check that real xpath (or xpath like) is equal any of xpath_list[0..n].
        #   Returns i+1
        # ******************************************************************************

DATA
    annotations = _Feature((3, 7, 0, 'beta', 1), (4, 0, 0, 'alpha', 0), 16...

FILE
    c:\repo\n0struct\n0struct\__init__.py


